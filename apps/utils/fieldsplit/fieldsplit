#!/usr/bin/perl -w

use strict;

use Getopt::Long;
use Memoize;

memoize ('transform_splitfield');
 
my( $h, $d, $f, $keep, $dir, $prefix, $suffix, $xform_outnames );
$d = $ENV{'DELIMITER'} || chr(0xfe);
$dir = './';
$prefix = $suffix = '';

&GetOptions(	"help"		=> \$h,
		"keepheader"	=> \$keep,
		"delim=s"	=> \$d,
		"field=n"	=> \$f,
		"path=s"	=> \$dir,
		"name=s"	=> \$prefix,
		"suffix=s"	=> \$suffix,
		"xform-name=s"	=> \$xform_outnames,
		);

if( $h || ! defined($f) ){
	usage();
	exit(1);
}

$f--;

my $flush = 10000;
my %fdat = ();
my $lineno = 0;

my $header;
if ( $keep ) {
	$header = <>;
}

while(my $lstr = <>){
	$lineno++;

	my @line = split(/\Q$d\E/, $lstr, -1);

	if( ! defined($line[$f]) || $line[$f] eq '' ){
		$line[$f] = '_blank_value';
	}

    my $split_key = transform_splitfield($line[$f]);
	push @{ $fdat{$split_key} }, $lstr;

	if( $lineno == $flush ){
		foreach my $key ( keys %fdat ){
			my $k = $key;
			$k =~ s/\s/_/g;
			$k =~ s/\//_/g;

			if ( $xform_outnames ) {
				eval "\$k =~ $xform_outnames;";
			}

			my $fname = $dir . '/' . $prefix . $k . $suffix;

		# if keeping the header and the file doesn't exist yet
		# open it & print the header to it
			if ( $keep && ! -f $fname ) {
				open(F, "> $fname") or die "$fname: $!\n";
				print F $header;
			} else {
				open(F, ">> $fname") or die "$fname: $!\n";
			}

			foreach my $l ( @{ $fdat{$key} } ){
				print F $l;
			}

			close(F);
			delete $fdat{$key};
		}
		$lineno = 0;
	}
}

foreach my $key ( keys %fdat ){
	my $fname = $dir . '/' . $prefix . $key . $suffix;

	if ( $keep && ! -f $fname ) {
		open(F, "> $fname") or die "$fname: $!\n";
		print F $header;
	} else {
		open(F, ">> $fname") or die "$fname: $!\n";
	}
	foreach my $l ( @{ $fdat{$key} } ){
		print F $l;
	}
	close(F);
}

exit(0);

sub transform_splitfield {
    my $k = shift;
    $k =~ s/[\r\n]//g;
    $k =~ s/\s/_/g;
    $k =~ s/\//_/g;

    if ( $xform_outnames ) {
        eval "\$k =~ $xform_outnames;";
    }

    return $k;
}

sub usage {
	print STDERR <<__USAGE__;

splits a file into multiple files according to a particular field value.

usage: $0 [-h] <-f N> [-d D] [-p dir] [file(s)]

	-h, --help	print this message and exit
	-f, --field N	split on field number N (required)
	-d, --delim D	specifies D as the field delimiter (default: 0xfe)
	-p, --path dir	specifies dir as directory in which files will be
			placed (default: ./)
	-n, --name <PREFIX> output filename prefix
	-s, --suffix <SUFFIX> output filename suffix
	-k, --keep	keep the header in all of the resulting files
	-x, --xform-names <SUBSTITUTION>
			user-supplied substitution regex to transform
			output names (e.g. 's/[^-\\w]//g')

filenames will be the -n prefix argument (if any) followed by whatever the
value of the field was (with spaces and slashes replaced with underscores),
or "_blank_value" for lines where the field was empty, followed by the
-s argument (if any).

NOTE: you should insure none of the files which will be created exist before
running this - new data will just be appended to the existing file in that
case.

__USAGE__
}
