#!CRUSH_PERL_PATH -w

#  Copyright 2008 Google Inc.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#

use strict;
use Getopt::Long;
use Memoize;

memoize('transform_splitfield');
 
my $MAX_FILE_HANDLES = 1023;
my $PRESERVE_FILE_HANDLES_PCT = 10;
my (%handles, %priority) = ();
my ($help, $d, $f, $label, $keep, $dir, $prefix, $suffix, $xform_outnames,
    $show_version, $buckets);
$d = $ENV{'DELIMITER'} || chr(0xfe);
# allow flush threshold to come from env so it can be tested
# with smaller input files
my $num_flush_buffer_lines = $ENV{FIELDSPLIT_FLUSH} || 10000;
$dir = './';
$prefix = $suffix = '';
Getopt::Long::Configure("no_ignore_case");
&GetOptions("help"         => \$help,
            "keepheader"   => \$keep,
            "delim=s"      => \$d,
            "field=n"      => \$f,
            "Field-label=s"=> \$label,
            "path=s"       => \$dir,
            "name=s"       => \$prefix,
            "suffix=s"     => \$suffix,
            "xform-name=s" => \$xform_outnames,
            "Version"      => \$show_version,
            "buckets=n"    => \$buckets,
            "S=n" => \$num_flush_buffer_lines,
           );

if ($show_version) {
  crush_version();
  exit(0);
}
if ($help) {
  usage();
  exit(0);
}

if (! defined($f) && ! defined($label)) {
  warn "$0: -f or -F option is required.  see $0 --help for details.\n";
  exit(1);
}

$d = expand_chars($d);

my $header;
if ($keep || $label) {
  $header = <>;
}

if ($f) {
  if ($f <= 0) {
    warn "$0: bad field index: $f\n";
    exit(1);
  }
  $f--;
} elsif ($label) {
  $f = field_str($label, $header, $d);
  if (! defined($f)) {
    warn "$0: field label not found: $label\n";
    exit(1);
  }
}

my %fdat = ();
my $lineno = 0;

# this is the sprintf format string for "bucketized" split keys, defined here
# to avoid recalculating length($buckets) inside the file loop.
my $fmt_str;
if ($buckets) {
  $fmt_str = '%' . length($buckets) . 'd';
}

while (my $lstr = <>) {
  $lineno++;

  my $split_key = transform_splitfield(get_line_field($lstr, $f, $d));

  if ($buckets) {
    $split_key = sprintf($fmt_str, hash($split_key) % $buckets);
  }
  push @{ $fdat{$split_key} }, $lstr;
  $priority{ $split_key }++;

  if ($lineno == $num_flush_buffer_lines) {
    flush_data(\%fdat);
    $lineno = 0;
  }
}

flush_data(\%fdat);
close_handles();

exit(0);

sub transform_splitfield {
    my $k = shift;

    $k =~ s/[\r\n]//go;
    return '_blank_value' if ( ! length $k );

    $k =~ s/\s/_/go;
    $k =~ s/\//_/go;

    if ($xform_outnames) {
        eval "\$k =~ $xform_outnames;";
    }
    return $k;
}

sub flush_data {
  my $fdat = shift;
  foreach my $key (keys %{ $fdat }){
    my $fname = $dir . '/' . $prefix . $key . $suffix;
    my $msk;
    if ($keep && ! -f $fname) {
      $msk = "> $fname";
    } else {
      $msk = ">> $fname";
    }

    if (! exists $handles{$key}) {
      my $fh;
      if (! open($fh, $msk)) {
                # real max
        $MAX_FILE_HANDLES = scalar keys %handles;
        my $tp = {};
        get_priority_hash($tp);
        close_handles($tp);
        open($fh, $msk) || die "unable to open $msk: $!";
      }
      $handles{$key} = $fh;
      print { $handles{$key} } $header if $keep;
    }
    # if keeping the header and the file doesn't
    # exist yet open it & print the header to it
    print { $handles{$key} } @{ $fdat->{$key} };
    delete $fdat->{$key};
  }
}

sub get_priority_hash {
  my $tp = shift;
  my $i = 0;
  my $x_percent = $MAX_FILE_HANDLES / $PRESERVE_FILE_HANDLES_PCT;
  for my $k (sort { $priority{$b} <=> $priority{$a} } keys %priority) {
    last if $i >= $x_percent;
    $tp->{$k} = 1;
    $i++;
  }
}

sub close_handles {
  my $tp = shift || {}; # null arg closes all FH
  for my $k (keys %handles) {
    if (! exists $tp->{$k}) {
      close($handles{$k});
      delete $handles{$k};
    }
  }
}

# based on the hashing algorithm used in Perl 5.005
# see http://www.perl.com/lpt/a/679
sub hash {
  my $str = shift;
  my $h = 0;
  foreach (split //, $str) {
    $h = $h * 33 + ord($_);
  }
  return $h;
}


sub usage {
  print STDERR <<__USAGE__;

splits a file into multiple files according to a particular field value.

usage: $0 [-h] <-f N> [-d D] [-p dir] [file(s)]

  -h, --help            print this message and exit
  -f, --field N         split on field number N (required)
  -d, --delim D         specifies D as the field delimiter (default: 0xfe)
  -p, --path dir        specifies dir as directory in which files will be
                        placed (default: ./)
  -n, --name <PREFIX>   output filename prefix
  -s, --suffix <SUFFIX> output filename suffix
  -k, --keep            keep the header in all of the resulting files
  -x, --xform-names <SUBSTITUTION>
                        user-supplied substitution regex to transform
                        output names (e.g. 's/[^-\\w]//g')
  -b, --buckets <N>     split data into at most N files, guaranteeing that
                        like field values are in the same output file.
  -S <N>                number of lines to store in memory before flushing
                        to disk. (default: 10000)

filenames will be the -n prefix argument (if any) followed by whatever the
value of the field was (with spaces and slashes replaced with underscores),
or "_blank_value" for lines where the field was empty, followed by the
-s argument (if any).

NOTE: you should insure none of the files which will be created exist before
running this - new data will just be appended to the existing file in that
case.

__USAGE__
}

m4_include(utils.pl)

# Local Variables:
# mode: perl
# End:

