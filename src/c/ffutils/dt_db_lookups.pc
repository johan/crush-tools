#include "data_transfer.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sqlca.h>

typedef struct {
	short spot_id_ind;
	short spot_tag_type_ind;
	short spot_tag_cat_ind;
	short spot_group_type_ind;
	short spot_tag_method_ind;
} spot_tag_attributes_ind_t;

/* like struct spotlight_tag_attributes, but without enums
 *  DEPENDS ON sizeof(enum) == sizeof(int)
 */
typedef struct {
	unsigned int spot_id;
	char type[SPOTLIGHT_TYPE_MAX_LEN + 1];
	char cat[SPOTLIGHT_TYPE_MAX_LEN + 1];
	int group_type;
	int tag_method;
} oracompat_spotlight_tag_attributes;

EXEC SQL BEGIN DECLARE SECTION;
varchar username[20];
varchar password[20];
varchar database[20];
spot_tag_attributes_ind_t	*tag_attributes_ind;
EXEC SQL END DECLARE SECTION;


void sql_error(char *);
void trim(char *);


static int db_connect (	char *db_name,
			char *db_uid,
			char *db_pass
) {
	strncpy( (char *) username.arr, db_uid, 20);
	strncpy( (char *) password.arr, db_pass, 20);
	strncpy( (char *) database.arr, db_name, 20);

	username.len = strlen( (char *) username.arr);
	password.len = strlen( (char *) password.arr);
	database.len = strlen( (char *) database.arr);

	EXEC SQL WHENEVER SQLERROR DO sql_error("Oracle error -- ");

	EXEC SQL CONNECT :username IDENTIFIED BY :password USING :database;

#ifdef DEBUG
	fprintf(stderr, "connected to %s as %s\n", database.arr, username.arr);
#endif

	return 0;
}


int get_spot_tag_attributes (
		llist_t *target,
		int spot_id,
		char *db_name,
		char *db_uid,
		char *db_pass
	){

	int	n_rows;

	oracompat_spotlight_tag_attributes *tag_attributes;
	struct spotlight_tag_attributes *persistant_tag_attr;

	if( (tag_attributes = malloc( sizeof( oracompat_spotlight_tag_attributes) ) ) == NULL ){
		return -1;
	}

	if( ( tag_attributes_ind = malloc( sizeof(spot_tag_attributes_ind_t) ) ) == NULL ){
		free(tag_attributes);
		return -1;
	}

	memset(tag_attributes, 0, sizeof(struct spotlight_tag_attributes));
	memset(tag_attributes_ind, 0, sizeof(spot_tag_attributes_ind_t));

	db_connect ( db_name, db_uid, db_pass );

	EXEC SQL DECLARE tag_attr_cursor CURSOR FOR
		SELECT	g.spot_id,
			g.tag_string,
			a.tag_string,
			g.activity_type_id,
			a.tag_method_id
		  FROM	spot_activity_group g,
			spot_activity a
		 WHERE	g.spot_id = :spot_id
		   AND	g.activity_group_id = a.activity_group_id;

	EXEC SQL OPEN tag_attr_cursor;

	/* break out of the while(1) loop when the
	   last row is hit */
	EXEC SQL WHENEVER NOT FOUND DO break;

	while(1){
		EXEC SQL FETCH tag_attr_cursor 
			INTO :tag_attributes:tag_attributes_ind;

		/* explicitly null-terminate & remove padding */
		tag_attributes->type[SPOTLIGHT_TYPE_MAX_LEN] = '\0';
		tag_attributes->type[SPOTLIGHT_CAT_MAX_LEN] = '\0';
		trim(tag_attributes->type);
		trim(tag_attributes->cat);

		persistant_tag_attr = malloc( sizeof( struct spotlight_tag_attributes ) );
		if ( ! persistant_tag_attr ) {
			break;
		}
		memcpy( persistant_tag_attr, tag_attributes, sizeof( struct spotlight_tag_attributes ) );
		ll_append_elem(target, persistant_tag_attr);

		n_rows++;
	}
	EXEC SQL CLOSE tag_attr_cursor;

	EXEC SQL COMMIT WORK RELEASE;
	free(tag_attributes);
	free(tag_attributes_ind);

	return n_rows;
}

static void sql_error(char *msg){
	char err_msg[128];
	int buf_len, msg_len;

	EXEC SQL WHENEVER SQLERROR CONTINUE;

	fprintf(stderr, "\n%s\n", msg);
	buf_len = sizeof(err_msg);
	sqlglm(err_msg, &buf_len, &msg_len);
	fprintf(stderr, "%.*s\n", msg_len, err_msg);

	EXEC SQL ROLLBACK RELEASE;

	exit(1);
}
